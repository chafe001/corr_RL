% -----------------------------------------------------------------------
% -----------------------  CORR_RL TASK CODE ----------------------------
% -----------------------------------------------------------------------

% Version history
% v1: first derivative of preceding xPairs task to incorporate
% multidimensional stimuli, enable definition of category manifolds within
% higher dimensional feature space.

% v2: branch (not in this code) that presented 1 pair (+ noise) per movie.
% Noise mechanism was to invert cue pairs (L/R). For me there was a weaker
% relationship between performance and noise level, learning was a little
% worse.  So no real benefit.

% v3: Building off of v1.  Adding option to use parametric curve images
% generated by Dave's line generation code (built off of Thomas's
% algorithm). Drawing too slow for runtime, files must be generated before
% the start of the run.

% v4: Modified to allow modified balance between main (signal) and ortho
% (noise) manifolds combined to make curves in blocks, to have low and high
% signal-to-noise shapes

% v5: Modified to hold bars presented at left and right screen locations
% constant between A and B states, as well as over all trials. We will
% start with one vector of bars to preset at left and right screen
% locations, and just change how they are paired to indicate states A and
% B.  This isolates correlation from any low level visual feature
% differences between states.  v5 looks to be working psychophysically.
% Initial RW model fit to my data shows increased learning rate and inverse
% temperature paramters on high correlation relative to low correlation
% blocks

% v6: Implementing visual simplification options as first step to NHP
% version. This will include simultaneous pairs, and fixed sequences.  Code
% works with 2 bars.  Think I can train NHP to perform task using sequences
% of 2 bars to include correlation discrimination at step 1. So potential
% training sequence:

% STEP 1: 2 bars, and 2 pairs, per state. Bars presented simultaneously, in
% fixed sequence. Correlation pattern 1, go left, pattern 2, go right.

% STEP 2: Present bars in each pair sequentially

% STEP 3: Randomize bar bar order in each movie

% STEP 4: Increase number of bars, complexity of discrimination (optional
% for preliminary)

% ---- notes from preceding xPairs task development

% FUTURE DIRECTIONS:
% 1. Modulate attention: synchrony will depend not only on stimulus
% correlation, but internal neural states, like attention. To modulate
% attention, have 1 pair in the stim movie appear in a color to induce a
% pop-out effect.  Contrast neural activity and performance when popout
% pair is an informative versus noise pair. In the former case, neural
% synchrony should add to stimulus synchrony and learning.  In the latter
% case, it should detract

% 2. Multiplex multiple stimulus dimensions into movie as separate
% 'channels', each of which conveys independent information about reward
% probablity.  Rank this from simple to complex, so that
% increments/decrements in reward probability depend on
% a. retinotopic location or color of stimulus
% b. associations between pairs of stimuli (implemented)
% c. number of stimuli of different color (if 3 red, then rewState = 1)
% d. categorical relationships between stimuli (if most large, then green)
% this will allow us to investigate how learning leads to abstraction, in
% an synaptically informed learning environment.
% e. vary spatial and temporal scales over which information must be
% integrated to learn the mapping between the stim movie and reward state,
% this will invoke working memory, and should require learning effects to
% climb visual hierarchy
% f. extend the above to include sequence learning, so that explicit
% sequences of stimuli, or the same stimuli in different sequences,
% indicate different reward states

% ------------------------------------------------------------------------
% PARAMETER HUNT: This task has a lot of knobs to turn, with a lot of
% unwanted perceptual and even some cognitive effects contaminating the
% computations we hope to recruit and study.  But maybe it just might work.
% Time to get data...

% 1st pass parameters:
% set two falsePairRatios, one of them should be 0 so subjects can get the
% mapping.  The other should be something like 0.3 or thereabouts, middling
% hard. Set pair reps to 100, and make the movie fast (flashy). Makes the
% potential to vary correlation stronger. Repetively drives neurons. stimDur 1
% frame, soa 10 or thereabouts.  Set high and low reward probs to 0.8 and
% 0.2 so get some RPEs going even with stable probabilities.

% 1st pass task performance:
% choppy, all or none, step functions, don't get it, don't get it, OK I got
% it.  This happens at various times within the block depending on
% perceptual difficulty of pairs selected.  No clear learning curve.
% Forgetting red/green mapping, so object bandit a complexity we may not
% need.  Implicit motor learning favors fixed response locations.
% Implementing. Modifying stimulus array to reduce explicit nature of
% process, pop-out of pairs, task weighs on spatial geometry discrimination
% rather than correlation detection (although these are related).  Need to
% add features, reduce spatial variance/cueing.


% NOTE ON GRAPHICS: adjust screen diagonal and distance in MonkeyLogic gui
% so combination produces about 20 pixels per degree.  Graphics more or
% less work across platforms at that resolution.

% DESIGN ALTERNATIVE: incorporate correlation directly into the choice
% stimuli themselves, pattern of correlation, sequence, order of changes in
% the two choice stimuli.  Visually simpler, removes spatial confounds.
% Information could be embedded in simlutanous states of the two choices
% while they are changing color, orientation, blinking on and off.

% Subjects learn association between pairs of stimuli and
% reward probabilities.  This embeds hebbian learning inside a bandit-style
% RL task.  Goal is to isolate neural synchrony and RPE components of
% synaptic plasticity, fit hybrid RL models to behavior, quantify
% interaction between these two forms of synaptic learning, while subjects
% learn.

% VERSION HISTORY
% v1 : initial effort, adapted from frames_task prototype, refining xPairs
% design
% v2 : refined state sequence, compiles, runs.  movieModes implemented:
% simultaneous, STDP, repeat, noise. xPairs implemented.
% v3: New way to implement xPairs.  Idea is to mix the two pairs that map
% to one reward state in each movie.  Also to mix the four pairs that map
% to the two reward states in different proportion. This makes it
% newsome/shadlen-esque, in the sense that we can have 60/40 red/green
% combinations of pairs in each movie. But the key thing is that the
% variable manipulated is degree of correlation within each movie, or maybe
% degree of correlation that implies reward state A vs B.
% v4: Removing eye fix for human beta testing.  Modified user-defined
% condition selection function xPairs_selectCond_v1.  Seems to be working.
% v5: Implementing progress bar to illustrate cumulative wins and losses
% within the block, with threshold for payout per block.
% v6: Implemented falsePairsRatio param to control how incorrect pairs (relative to reward state)
% are mixed to vary correlation strength of movies. Implemented corrStrength_mode param (either
% 'pairMix' or 'noiseMix') to flexibily use either pairs from the incorrect
% reward state (pairMix) or noisePairs (noiseMix) to modulate correlation
% strength. Updated user output.  Corrected bug in buildTrials (pairSeq
% vector was incorrectly set up, scrambling relationship between stim pairs
% and reward state). Discovered (remembered) that code will not work
% properly if when changes are made that vary the dimension of condArray,
% changes are not made to the condition file to reflect the new mapping
% between conditions and blocks.  As it is set up now, any change to the
% dimension of the looping variables (including falsePairsRatio) that
% ulimately change the dimensionality of condArray will introduce problems.

% V3 code seems to have good visual
% flexibility to break apparent motion illusion, control timing, noise
% level, other perceptually relevant manipulations.  Need to find a sweet
% spot minimizing perceptual/conscious/model based processing of task.
% Maybe brief and masked stimuli with added noise so there is not so much
% shape (spatial) pop-out of stimuli.  What is supposed to be a correlation
% task looks like a shape task (but shape is spatial correlation so maybe
% OK).  Maybe explore correlation in other domains.  For example, make the
% choice stimuli mutli-dimensional (color, orientation, spatial frequency of gabor
% for example). See if finding feature correlations holding location
% constant has different perceptual appearance.

% This should be good for psychophysics, can compute thresholds, etc.
% Links also to David Leopold's experiment, we can look for biases in
% STDP pairs shifting thresholds. That is, if A->B with greater frequency,
% does this shift psychophyscial performance of any pairs with B.  Will
% need to fit psychometric functions to performance to detect this most
% likely, small effects, need sensitive measures.

% So imagining a couple of modes:
% 1. Proportional xPairs. Mix reward state A and B pairs (all 4 pairs
% randomly selected by buildStimPairs) in varying proportion.
% 2. Proportional xPairs with noise. Like above but varying number of noise
% pairs included.  This generally weakens correlation strength between
% individual stimuli.

% Thinking to vary association strength on a trial-by-trial basis (rather
% than blocks).  This keeps association strength and RPE varying at the
% trial level, and evaluation of association strength and RPE on choice
% probability also at the trial rather than block levels.

% Algorithm:
% Main difference is in how stim pairs are allocated to conditions.  In
% this case, each condition will be associated with all 4 stimuli and all
% 4 pairs between the stimuli, the only difference being the proportion of
% pairs implicating each state and the degree of noise (if implemented).

% Task design features:

% 1. CROSS-PAIR DESIGN.  Four stimuli (peripheral dots or gabors) are
% variously combined to indicate whether red or green choice target is
% associated with high (80%) or low (20%) reward probability at the end of
% the trial. Crossing is done such that each stimulus location is
% associated with R and G choices with each probability.  This ensures that
% the decision cannot be based on any individual stimulus at outset.
% Association between two stimuli must be learned to consistently select
% high value target. Given 4 stimuli, the crossing would be as follows:

% 1-2 : Green (80%)
% 3-4 : Green (80%)
% 1-3 : Red (80%)
% 2-4 : Red (80%)

% Notice each single stimulus is associated with Red and Green with equal
% probability.  Information about whether Red or Green choice stimulus is
% high reward probability is conveyed by pair (learned association) only

% ALTERNATIVE DESIGN: on some trials, only a single stimulus is shown, on
% others pairs of stimuli are shown. The implication about reward state of
% the pair can be determined by comparison of choices to the pair and
% choices to the individual stimuli. In some pairs, inclusion of only 1
% stimulus informs reward state.  In other pairs, it is the combination.
% Optionally, and single stimulus instructs 50/50 reward state (choices
% should be random).  This might be simpler design 1 pair - 1 reward state
% mapping, rather than 2 pairs -> 1 reward state mapping

% 2. DIRECTIONAL ASSOCIATIONS. Pairs are presented in fixed order with STDP
% interstimulus intervals. Stimulus 1 consistently just before stimulus 2
% strengthens 1 to 2 synapses.  Stimulus 1 implies stimulus 2, but not the
% converse.

% Extanding the cross-pair design with ordinal information produces

% 1 -> 2 : Green
% 3 -> 4 : Green
% 3 -> 1 : Red
% 2 -> 4 : Red

% with the arrow indicating the order of presentation and the direction of
% the learned association.  Note further that orders are arranged such that
% any single stimulus implies only 1 other stimulus as its partner.  This
% could be manipulated in some conditions where stimulus 1 implies both 2
% and 3, to contrast neural coding and behavioral read-outs between
% unambiguous and ambiguous pairings.

% 3. SINGLETON PROBES.  If the directional association manipulation works,
% choices in response to a singleton stimulu would provide a behavioral
% read-out of learning. For example, after learning that:
% Stimulus 1 -> 2 : Green
% presentation of stimulus 1 alone should be associated with a Green
% choice, whereas presentation of stimulus 2 alone would be associated
% with Red and Green choices with equal probability.

% 4. VARIABLE ASSOCIATIVE STRENGTH.  Introduce variable numbers of noise
% pairs that modulate the correlation strength between each stimulus in
% informative pairs with its partner.  So if subjects learn that:
% Stimulus 1 -> 2 : Green
% have stimulus 1 appear with stimulus 2 on 50% of trials, and stimulus 1
% appear with stimulus 5 on 50% of trials.  Have 1->5 indicate Green and
% Red with equal probability

% 5. REPETITIVE STIMULI.  To amplify visually driven synchrony, and
% incorporate varying amounts of noise into single trials, present a movie
% in which successive frames show pair - blank - pair - blank ... Moduluate
% the proporation of informative and noise pairs shown.

% 6. ATTENTION. Attention is associated with neural synchrony (by some
% accounts). Adding orienting probes before pair presentation might amplify
% neural synchrony, modulate learning.

% 7. SEQUENCE LEARNING.  Expansion of ISI beyond time constant of synaptic
% eligibility trace will recruit working memory to bridge the gap between
% the two stimuli.  Thus xPairs morphs seamlessly into a sequence learning
% task.

% NOTES ON STIMULUS TIMING FOR LEARNING EFFECTS
% McMahon and Leopold (2010) tested effect of stimulus timing and order on
% plasticity of face perception. Two faces, variable morph levels between
% them, task to identify morphs as face A or B. Obtain psychophysical
% thresolds before and after image pairing.  Image pairing paradigm:
% - each trial, an image pair was presented (face or nonface) at fovea
% - 120 trials, 100 face pairs, 20 nonface pairs
% - each image in pair visible for 1 screen refresh (10 ms at 100 Hz)
% - SOA 10-100 ms
% - After 1 pair, press button if face, withhold if nonface (attention)
% - Interpair interval 800-1200 ms (ITI)
% - Trial length, fix (500 ms), pair (max 120 ms), 1200 ms ITI = ~ 2 s
% - Plasticity effect peaked at SOA = 20 ms, 100 pairs sufficient

% TRIAL STRUCTURE for xPAIRS PROTOTYPE
% - fixation
% - Single target pair flashed
% - Red and Green choice targets appear at left/right (randomized)
% - Press left/right response key
% - Probabilitic reward based on image pair shown
% - To vary associative strength, hold SOA and image order constant within
%   block, vary SOA and image order BETWEEN BLOCKS, compare neurons and
%   behavior between blocks

% Algorithmic steps to build trial stack:

% 1. Establish STIMULUS ARRAY.  Allow for greater than 4 stimulus locations
% to enable introduction of noise pairs

% 2. Build TRIAL STACK for blocks of trials.  Within each block:
% a. Select 4 stimulus locations at random from array
% b. Establish 4 cross-pairs (see above) among 4 selected stimuli
% c. Assign 2 pairs each to Green (80% rew prob)and Red (80% rew prob)
% c. Set stimulus order for each pair (1->2 or 2->1 etc).
% d. Set interstimulus interval
% e. Define noise pairs, if enabled.
% f. Insert noise pairs at variable proportion, if enabled.

% 3. Present CHOICE ARRAY, Red(Left) green(right), or reverse at random.
% Can add second choice pair color to dissociate neural representation of
% state from predictions of choice color. So choice array might be
% Red-Green on some trials, and Yellow-Purple on others.  Find neurons that
% generalize over xPairs coding same state and generalize over choice
% colors.  These are abstract category neurons (as a bonus).

% 4. Monitor BUTTON PRESS (left, right)

% 5. Deliver PROBABILISITC REWARD (Bandit-style)

% VERSION HISTORY
% --- v1:
% - Start with 1 pair shown per trial using design above.
% - Incorporate singleton probes.
% - Incorporate noise pairs, still only 1 pair per trial.
% - Have people run this.  Compare performance +/- noise. Fit RL models.


% -------------------------------------------------------------------------
% ---------------------- TASK CONTROL SWITCHES ----------------------------
% -------------------------------------------------------------------------

% --- Display joystick
% This will display the joystick cursor, but for both the experimenter and
% subject screen. Not sure there's a way to only display to experimenter
% screen, but I think the joystick cursor should show in replay.
showcursor(false);

% --- Multiple hits
% require that 2-n correct trials are performed in a row before delivering
% reward drops equal to the number of successive trials on the last trial.
% If multipleHits = 0, then disabled
multipleHits = 0; %3


% -------------------------------------------------------------------------
% --------------------------- CONSTANTS -----------------------------------
% -------------------------------------------------------------------------
% Task objects. Numbers are column indices in the conditions *.txt file and
% control how ML accesses stimulus information from the conditions file. We
% are using this mostly to control stimulus positions.  Stimuli identities
% are controlled by setting the filenames of *.png files to read from disk
taskObj_fix = 1;

trialerror(0, 'validResp', 1, 'earlyResp', 2, 'noResp');

% Eye and joy fixation window (in degrees)
eye_radius = 3;
joy_radius = 3;

% Reward sizes
rewDur1 = 85;
numDrops1 = 2;

% joystick response coordinates
leftTarg = [-9.5, 0];
rightTarg = [9.5, 0];

% -------------------------------------------------------------------------
% ---------------------- TRIAL OUTCOME VARIABLES --------------------------
% -------------------------------------------------------------------------
% --- these variables save behavioral events to the outfile

% trialResult is a string that should take on one of the following values
% 'null' (initialized)
% 'noEyeJoyFix'
% 'breakFix_eye'
% 'breakFix_joy'
% 'breakFix_eye_joy'
% 'noResponse'
% 'correctChoice'
% 'incorrectChoice'
trialResult = 'null';

% resultScene is the scene in which the result occurred, and should take
% on one of the following values
% 'null' (initialization)
% 'preCue'
% 'cue'
% 'post_cue_resp'
% 'post_cue_return'
% 'isi'
% 'probe'
% 'post_probe_resp'
% 'post_probe_return'
% 'post_probe_fix'
% 'feedback'
% 'reward'
% 'post_reward_fix'
resultScene = 'null';


% -------------------------------------------------------------------------
% ------------------- INIT TRIAL FLAGS AND COUNTERS -----------------------
% -------------------------------------------------------------------------
% --- These variables track behavioral events for trial control

% flag to call 'return' to end trial prematurely if error
abortTrial = false;

% flag for determining trialerror if all scenes completed successfully
totalTrialSuccess = 0;

% flag to determine if probe response was successfully completed (out and
% back)
stimRespCompleted = false;

% -------------------------------------------------------------------------
% ------------------------ CHECK HARDWARE ---------------------------------
% -------------------------------------------------------------------------

% check eye input is detected
if ~exist('eye_','var'), error('This demo requires eye signal input. Please set it up or try the simulation mode.'); end

% set hotkey for exit
hotkey('x', 'escape_screen(); assignin(''caller'',''continue_'',false);');

% Note for manual reward: during task, [R] is preprogrammed as a manual
% reward hotkey and will dispense the amount of reward specified in the
% section of the main menu
% [R] key: Delivers a manual reward (initial pulse duration: 100 ms, juiceline: as determined in Reward of the main menu).

% -------------------------------------------------------------------------
% -------------------------- PARAMETERS -----------------------------------
% -------------------------------------------------------------------------
dbstop if error;
showcursor('off');
taskObj_fix = 1;

% -------------------------------------------------------------------------
% --------------------------- STATE TIMES ---------------------------------
% -------------------------------------------------------------------------

% call fx to set trial timing
times = corr_RL_setTimes_v3();

% save times to TrialRecord
TrialRecord.User.times = times;

% -------------------------------------------------------------------------
% -------------- BUILD CONDITION AND TRIAL ARRAYS -------------------------
% -------------------------------------------------------------------------
% DO THIS ONCE AT START OF RUN (if first trial)
% This code generates the condition array, and the trial array, and stores
% these variables in the TrialRecord.  TrialRecord is defined by ML app
% code, and we can store user-defined variables at the trial level in this
% variable for future reference.

% conditions: each condition, specified by a number, provides all the
% information needed to generate a trial.

% trials: a vector of condition numbers corresponding to the trial types
% and frequencies we want to present to each subject (the trial 'stack').
% We draw randomly from the trialAra to specify the condition number for
% each trial
if TrialRecord.CurrentTrialNumber == 1

    [condArray, params] = corr_RL_buildTrials_v5();

    % store output in TrialRecord so variables live (have scope) beyond
    % this trial.  Other variables in script are only defined during the
    % trial.
    TrialRecord.User.condArray = condArray;
    % TrialRecord.User.condReps = condReps;
    TrialRecord.User.params = params;
    % init condition reps remaining counter (condRepRem) to initial
    % condition rep array
    % TrialRecord.User.condRepsRem = condReps;
    TrialRecord.User.times = times;

    switch TrialRecord.User.params.stimulusType
        case 'bars'
            TrialRecord.User.codes = corr_RL_setBarCodes_nhp_v3();
        case 'curves'
            TrialRecord.User.codes = corr_RL_setCurveCodes_v3();
    end

end

% -------------------------------------------------------------------------
% --------------------- GENERATE STIMULUS MOVIE ---------------------------
% -------------------------------------------------------------------------

switch TrialRecord.User.params.stimulusType

    case 'bars'

        switch TrialRecord.User.params.pairMode
            case 'randList'
                [movieFrames, pairSeq, pairs] = corr_RL_generateBarMovie_v3(TrialRecord);

            case 'xPairs'
                [movieFrames, pairSeq, pairs] = corr_RL_generateBarMovie_v1(TrialRecord);

        end

        TrialRecord.User.movieFrames = movieFrames;
        TrialRecord.User.pairSeq = pairSeq;
        TrialRecord.User.pairs = pairs;

    case 'curves'
        % [movieFrames] = corr_RL_generateCurveMovie_v1(TrialRecord);
        [movieFrames, movieParams] = corr_RL_generateCurveMovie_v3(TrialRecord);
        TrialRecord.User.movieFrames = movieFrames;
        TrialRecord.User.movieParams = movieParams;
end


% -------------------------------------------------------------------------
% ----------------- INIT WITHIN BLOCK RESULT COUNTERS -----------------------
% -------------------------------------------------------------------------
if TrialRecord.CurrentTrialWithinBlock == 1
    TrialRecord.User.blockWins = 0;
    TrialRecord.User.blockLosses = 0;
    TrialRecord.User.netWins = 0;
end

% -------------------------------------------------------------------------
% ---------------- EXTRACT TRIAL INFO FROM TrialRecord --------------------
% -------------------------------------------------------------------------
t = TrialRecord.CurrentTrialNumber;
c = TrialRecord.CurrentCondition;
b = TrialRecord.CurrentBlock;

% -------------------------------------------------------------------------
% ---------------- SET CHOICE AND REWARD PARAMETERS -----------------------
% -------------------------------------------------------------------------

% set the choice feebback images
choices.rewImg = 'rewRing.png';
choices.choiceImg = 'choiceRing.png';

% init choice variables
choices.chosenSide = [];
choices.responseKey = [];
choices.choseCorrect = []; % selected the choice with the higher reward probability
choices.madeValidResp = [];


% *************************************************************************************************
% *************************************************************************************************
% ************************ BUILD AND RUN SCENES (RUN TRIAL) BELOW *********************************
% *************************************************************************************************
% *************************************************************************************************

% flag to call 'return' to end trial prematurely if error
abortTrial = false;

% --- ML notes
% ML provides a library of 'adapters'.  Each performs a rudimentary
% function (monitor eye position, present stimulus, set timer, etc). We
% concatenate adapters to create functions with complex properties.
% Adaptors are objects.  One object is instantiated then passed as an
% argument to the constructor for the next object (concatenation).
% Thus the 'parent' adaptor inherits the properties of the 'child' adaptor
% (passed to the constructor for the parent).

% see: https://monkeylogic.nimh.nih.gov/docs.html for documentation, in
% particular, see:
% https://monkeylogic.nimh.nih.gov/docs_RuntimeFunctions.html for a
% description of the timing script functions (adapters)

% -------------------------------------------------------------------------
% PRETRIAL period

% --- PRINT TRIAL AND CUE MOVIE INFO TO USER SCREEN
switch TrialRecord.User.condArray(c).state
    case 1
        keyStr = 'Correct Key: LEFT';
    case 2
        keyStr = 'Correct Key: RIGHT';
end

switch TrialRecord.User.params.stimulusType

    case 'bars'
        trlInfoStr = strcat(keyStr, ...
            '  Trial:', num2str(t), ...
            '  Block:', num2str(b), ...
            '  Cond:', num2str(c), ...
            '  Cue percent:', num2str(TrialRecord.User.condArray(c).cuePercent), ...
            '  Total pairs: ', num2str(TrialRecord.User.params.numMoviePairs));

        pair1_Angles_str = strcat('Pair1 L_ang:', num2str(TrialRecord.User.condArray(c).cuePairs(1).leftStim.Angle), ...
            '  L_RGB: ', num2str(TrialRecord.User.condArray(c).cuePairs(1).leftStim.FaceColor), ...
            '  L_FN: ', TrialRecord.User.condArray(c).cuePairs(1).leftStim.FileName, ...
            '  R_ang: ', num2str(TrialRecord.User.condArray(c).cuePairs(1).rightStim.Angle), ...
            '  R_RGB: ', num2str(TrialRecord.User.condArray(c).cuePairs(1).rightStim.FaceColor), ...
            '  R_FN: ', TrialRecord.User.condArray(c).cuePairs(1).rightStim.FileName);

        pair2_Angles_str = strcat('Pair2 L_ang:', num2str(TrialRecord.User.condArray(c).cuePairs(2).leftStim.Angle), ...
            '  L_RGB: ', num2str(TrialRecord.User.condArray(c).cuePairs(2).leftStim.FaceColor), ...
            '  L_FN: ', TrialRecord.User.condArray(c).cuePairs(2).leftStim.FileName, ...
            '  R_ang: ', num2str(TrialRecord.User.condArray(c).cuePairs(2).rightStim.Angle), ...
            '  R_RGB: ', num2str(TrialRecord.User.condArray(c).cuePairs(2).rightStim.FaceColor), ...
            '  R_FN: ', TrialRecord.User.condArray(c).cuePairs(2).rightStim.FileName);

        dashboard(1, trlInfoStr, [1 1 1], 'FontSize', 8);
        dashboard(3, pair1_Angles_str, [1 1 1], 'FontSize', 8);
        dashboard(4, pair2_Angles_str, [1 1 1], 'FontSize', 8);

    case 'curves'
        trlInfoStr = strcat(keyStr, ...
            '  Trial:', num2str(t), ...
            '  Block:', num2str(b), ...
            '  Cond:', num2str(c), ...
            '  State:', num2str(TrialRecord.User.condArray(c).state));

        % --- DISPLAY movieParams for this movie
        cmt = TrialRecord.User.movieParams.curveMovieType;
        cmo = TrialRecord.User.movieParams.orientation;
        ms = num2str(TrialRecord.User.movieParams.mainSeq);
        os = num2str(TrialRecord.User.movieParams.orthoSeq);
        mt = num2str(TrialRecord.User.movieParams.mainTvalSeq);
        ot = num2str(TrialRecord.User.movieParams.orthoTvalSeq);

        movieInfoStr1 = strcat('movieP Type:', cmt, '  Orient: ', cmo, '  ms: ', ms, '  os: ', os);
        movieInfoStr2 = strcat('mt: ', mt);
        movieInfoStr3 = strcat('ot: ', ot);

        dashboard(1, trlInfoStr, [0 0 0], 'FontSize', 8);
        dashboard(3, movieInfoStr1, [0 0 0], 'FontSize', 8);
        dashboard(4, movieInfoStr2, [0 0 0], 'FontSize', 8);
        dashboard(5, movieInfoStr3, [0 0 0], 'FontSize', 8);

end

% write event codes to store ML condition and trial numbers
mult256 = floor(TrialRecord.CurrentTrialNumber/256) + 1;
mod256 = mod(TrialRecord.CurrentTrialNumber, 256);
% replaced idle() with eventmarker() for the human task code, prevents
% blinking of reward bar when called
eventmarker([TrialRecord.CurrentCondition mult256 mod256]);

% -------------------------------------------------------------------------
% SCENE 1: PRECUE FIX

% --- BUILD ADAPTOR CHAINS
% See TBT or TOPX recording code for additional notes

% present fix target, activatate eye window
sc1_eyeCenter = SingleTarget(eye_);
sc1_eyeCenter.Target = taskObj_fix;
sc1_eyeCenter.Threshold = eye_radius;

% write event code for acquiring eye fixation
sc1_eyeCenter_oom = OnOffMarker(sc1_eyeCenter);
sc1_eyeCenter_oom.OnMarker = TrialRecord.User.codes.gazeFixAcq;
sc1_eyeCenter_oom.ChildProperty = 'Success';

% present joystick target, activate joystick window
sc1_joyCenter = SingleTarget(joy_);
sc1_joyCenter.Target = taskObj_fix; % redundant
sc1_joyCenter.Threshold = joy_radius;

% write event code for acquiring joy fixation
sc1_joyCenter_oom = OnOffMarker(sc1_joyCenter);
sc1_joyCenter_oom.OnMarker = TrialRecord.User.codes.joyFixAcq;
sc1_joyCenter_oom.ChildProperty = 'Success';

% 'and' eye and joy together
sc1_eyejoy = AndAdapter(sc1_eyeCenter_oom);
sc1_eyejoy.add(sc1_joyCenter_oom);

% pass eyejoy to WaitThenHold, require eye and joy fixation for a period
sc1_wtHold = WaitThenHold(sc1_eyejoy);  % WaitThenHold will trigger once both the eye and the joystick are in the center and will make sure that they are held there for the duration of this scene
sc1_wtHold.WaitTime = times.sc1_precue_eyejoy_waitTime_ms;
sc1_wtHold.HoldTime = times.sc1_precue_eyejoy_holdTime_ms;

% draw rewBox to indicate accumulated rewards
% NOTE: PASS wtHold INTO BoxGraphic
sc1_rewBox = BoxGraphic(sc1_wtHold);
netWinBox_height = TrialRecord.User.params.rewBox_height;
netWinBox_width = TrialRecord.User.netWins * TrialRecord.User.params.rewBox_degPerWin;
maxWinBox_width = TrialRecord.User.params.rewBox_width;
% orange
% netWinBox_edgeColor = [0.9290 0.6940 0.1250];
% netWinBox_faceColor = [0.9290 0.6940 0.1250];
% light blue
netWinBox_edgeColor = [0.3010 0.7459 0.9330];
netWinBox_faceColor = [0.3010 0.7459 0.9330];

% figure out where to print white netWin reward box so it is left aligned
% with left edge of black maxWin reward box.  X position coordinate
% specifies screen coordinates of center of rectangle graphic. The center
% of the white bar is screen center -1/2 black bar width +1/2 white bar
% width
netWindBox_center = (netWinBox_width / 2) - (maxWinBox_width / 2);

% rewBox.List = {[1 1 1], [1 1 1], [netWinBox_width netWinBox_height], [netWindBox_center TrialRecord.User.params.rewBox_yPos]; [0 0 0], [0 0 0], [maxWinBox_width netWinBox_height], [0 TrialRecord.User.params.rewBox_yPos - netWinBox_height]};
sc1_rewBox.List = {netWinBox_edgeColor, netWinBox_faceColor, [netWinBox_width netWinBox_height], [netWindBox_center TrialRecord.User.params.rewBox_yPos]; [0 0 0], [0 0 0], [maxWinBox_width netWinBox_height], [0 TrialRecord.User.params.rewBox_yPos - netWinBox_height]};

% % pass rewBox to timer, set rewBox time to be lo
% sc1_rewBox_tc = TimeCounter(sc1_rewBox);
% sc1_rewBox_tc.Duration = times.sc1_rewBox_ms;
%
% % combine eyejoy and rewBox
% sc1_eyejoy_rewBox = Concurrent(sc1_wtHold);
% sc1_eyejoy_rewBox.add = sc1_rewBox_tc;

% --- CREATE AND RUN SCENE USING ADAPTOR CHAINS
scene1 = create_scene(sc1_rewBox);
% fliptime is time the trialtime in ms at which the first frame of the
% screen is pressented and is the return value of run_scene.  Logs timing
% of scene transitions
scene1_start = run_scene(scene1, TrialRecord.User.codes.gazeFixAcq); %'pretrial'

% --- CHECK BEHAVIORAL OUTCOMES
% Note: this status checking structure copied from ML documentation on
% WaitThenHold()
if sc1_wtHold.Success
    dashboard(4, 'PRECUE FIX sc1_wtHold: Success');
elseif sc1_wtHold.Waiting
    idle(0, [], TrialRecord.User.codes.neverFix);
    trialerror(4); %'No fixation'
    abortTrial = true;
    trialResult = 'noEyeJoyFix';
    resultScene = 'preCue';
    dashboard(4, 'PRECUE FIX sc1_wtHold: Waiting');
else  % fixation acquired but broken
    trialerror(3);    %'Break fixation'
    abortTrial = true;
    dashboard(4, 'PRECUE FIX sc1_wtHold: Broken fixation');
    % figure out which fixation was broken, eye or joy, by checking last
    % sampled value of Success property at time that adapter chain
    % terminated
    if sc1_eyeCenter.Success && ~sc1_joyCenter.Success
        dashboard(5, 'sc1_eyeCenter: Success');
        dashboard(6, 'sc1_joyCenter: Fail');
        trialResult = 'breakFix_joy';
        resultScene = 'preCue';
        idle(0, [], codes.brokeJoyFix);
    elseif ~sc1_eyeCenter.Success && sc1_joyCenter.Success
        dashboard(5, 'sc1_eyeCenter: Fail');
        dashboard(6, 'sc1_joyCenter: Success');
        trialResult = 'breakFix_eye';
        resultScene = 'preCue';
        idle(0, [], TrialRecord.User.codes.brokeGazeFix);
    elseif ~sc1_eyeCenter.Success && ~sc1_joyCenter.Success % not likely, but possible
        dashboard(5, 'sc1_eyeCenter: Fail');
        dashboard(6, 'sc1_joyCenter: Success');
        trialResult = 'breakFix_eye_joy';
        resultScene = 'preCue';
        idle(0, [], TrialRecord.User.codes.brokeBothFix);
    end
end

% bomb trial if error
if abortTrial
    % --- SAVE USER VARS
    bhv_variable( ...
        'TrialRecord', TrialRecord, ...
        'choices', choices, ...
        'condArray', TrialRecord.User.condArray, ...
        'params', TrialRecord.User.params, ...
        'movieFrames', TrialRecord.User.movieFrames);
    return;
end



% -------------------------------------------------------------------------
% SCENE 2: PRESENT STIM MOVIE, ERROR IF KEY RESPONSE

% --- MAKE ADAPTOR(S)
% --- 1. eye joy control
% present fix target, activatate eye window
sc2_eyeCenter = SingleTarget(eye_);
sc2_eyeCenter.Target = taskObj_fix;
sc2_eyeCenter.Threshold = eye_radius;

% write event code for acquiring eye fixation
sc2_eyeCenter_oom = OnOffMarker(sc2_eyeCenter);
sc2_eyeCenter_oom.OnMarker = TrialRecord.User.codes.gazeFixAcq;
sc2_eyeCenter_oom.ChildProperty = 'Success';

% present joystick target, activate joystick window
sc2_joyCenter = SingleTarget(joy_);
sc2_joyCenter.Target = taskObj_fix; % redundant
sc2_joyCenter.Threshold = joy_radius;

% write event code for acquiring joy fixation
sc2_joyCenter_oom = OnOffMarker(sc2_joyCenter);
sc2_joyCenter_oom.OnMarker = TrialRecord.User.codes.joyFixAcq;
sc2_joyCenter_oom.ChildProperty = 'Success';

% 'and' eye and joy together
sc2_eyejoy = AndAdapter(sc2_eyeCenter_oom);
sc2_eyejoy.add(sc2_joyCenter_oom);

% pass eyejoy to WaitThenHold, require eye and joy fixation for a period
sc2_wtHold = WaitThenHold(sc2_eyejoy);  % WaitThenHold will trigger once both the eye and the joystick are in the center and will make sure that they are held there for the duration of this scene
sc2_wtHold.WaitTime = times.sc2_precue_eyejoy_waitTime_ms;
sc2_wtHold.HoldTime = times.sc2_precue_eyejoy_holdTime_ms;

% draw rewBox to indicate accumulated rewards
% NOTE: PASS wtHold INTO BoxGraphic
sc2_rewBox = BoxGraphic(sc2_wtHold);
netWinBox_height = TrialRecord.User.params.rewBox_height;
netWinBox_width = TrialRecord.User.netWins * TrialRecord.User.params.rewBox_degPerWin;
maxWinBox_width = TrialRecord.User.params.rewBox_width;
% orange
% netWinBox_edgeColor = [0.9290 0.6940 0.1250];
% netWinBox_faceColor = [0.9290 0.6940 0.1250];
% light blue
netWinBox_edgeColor = [0.3010 0.7459 0.9330];
netWinBox_faceColor = [0.3010 0.7459 0.9330];

% figure out where to print white netWin reward box so it is left aligned
% with left edge of black maxWin reward box.  X position coordinate
% specifies screen coordinates of center of rectangle graphic. The center
% of the white bar is screen center -1/2 black bar width +1/2 white bar
% width
netWindBox_center = (netWinBox_width / 2) - (maxWinBox_width / 2);

% rewBox.List = {[1 1 1], [1 1 1], [netWinBox_width netWinBox_height], [netWindBox_center TrialRecord.User.params.rewBox_yPos]; [0 0 0], [0 0 0], [maxWinBox_width netWinBox_height], [0 TrialRecord.User.params.rewBox_yPos - netWinBox_height]};
sc2_rewBox.List = {netWinBox_edgeColor, netWinBox_faceColor, [netWinBox_width netWinBox_height], [netWindBox_center TrialRecord.User.params.rewBox_yPos]; [0 0 0], [0 0 0], [maxWinBox_width netWinBox_height], [0 TrialRecord.User.params.rewBox_yPos - netWinBox_height]};

% --- 2. movie adaptor
sc2_movie = ImageChanger(sc2_rewBox);
sc2_movie.List = movieFrames;
sc2_movie.Repetition = 1;

% --- CREATE AND RUN SCENE USING ADAPTOR CHAINS
scene2 = create_scene(sc2_movie);
scene2_start = run_scene(scene2);

% --- SAVE FRAME TIMES IN MOVIE
TrialRecord.User.movieFrameTimes = sc2_movie.Time;
% NOTE: each new User VAR has to be explicitly included in bhv_variable fx
% call at end of this script, so essential to include TrialRecord.User.movieFrameTimes
% in the list of variables saved to include it in the bhv2 behavioral
% outfile

% --- CHECK BEHAVIORAL OUTCOMES
% Note: this status checking structure copied from ML documentation on
% WaitThenHold()
if sc2_wtHold.Success
    dashboard(4, 'PRECUE FIX sc2_wtHold: Success');
elseif sc2_wtHold.Waiting
    idle(0, [], TrialRecord.User.codes.neverFix);
    trialerror(4); %'No fixation'
    abortTrial = true;
    trialResult = 'noEyeJoyFix';
    resultScene = 'preCue';
    dashboard(4, 'PRECUE FIX sc2_wtHold: Waiting');
else  % fixation acquired but broken
    trialerror(3);    %'Break fixation'
    abortTrial = true;
    dashboard(4, 'PRECUE FIX sc2_wtHold: Broken fixation');
    % figure out which fixation was broken, eye or joy, by checking last
    % sampled value of Success property at time that adapter chain
    % terminated
    if sc2_eyeCenter.Success && ~sc2_joyCenter.Success
        dashboard(5, 'sc2_eyeCenter: Success');
        dashboard(6, 'sc2_joyCenter: Fail');
        trialResult = 'breakFix_joy';
        resultScene = 'preCue';
        idle(0, [], codes.brokeJoyFix);
    elseif ~sc2_eyeCenter.Success && sc2_joyCenter.Success
        dashboard(5, 'sc2_eyeCenter: Fail');
        dashboard(6, 'sc2_joyCenter: Success');
        trialResult = 'breakFix_eye';
        resultScene = 'preCue';
        idle(0, [], TrialRecord.User.codes.brokeGazeFix);
    elseif ~sc2_eyeCenter.Success && ~sc2_joyCenter.Success % not likely, but possible
        dashboard(5, 'sc2_eyeCenter: Fail');
        dashboard(6, 'sc2_joyCenter: Success');
        trialResult = 'breakFix_eye_joy';
        resultScene = 'preCue';
        idle(0, [], TrialRecord.User.codes.brokeBothFix);
    end
end

% bomb trial if error
if abortTrial
    % --- SAVE USER VARS
    bhv_variable( ...
        'TrialRecord', TrialRecord, ...
        'choices', choices, ...
        'condArray', TrialRecord.User.condArray, ...
        'params', TrialRecord.User.params, ...
        'movieFrames', TrialRecord.User.movieFrames, ...
        'movieFrameTimes', TrialRecord.User.movieFrameTimes);
    return;
end



% -------------------------------------------------------------------------
% SCENE 3: RESPONSE WINDOW

% --- MAKE ADAPTOR(S)
% Present fixation target and establish XY position window for eye
sc3_eyeCenter = SingleTarget(eye_);
sc3_eyeCenter.Target = taskObj_fix;
sc3_eyeCenter.Threshold = eye_radius;

% pass eye to WaitThenHold
sc3_wtHold = WaitThenHold(sc3_eyeCenter);
sc3_wtHold.WaitTime = probe_eye_waitTime;
sc3_wtHold.HoldTime = probe_eye_holdTime; % entire duration of scene

% MultiTarget()
sc3_mTarg_joy = MultiTarget(joy_);
sc3_mTarg_joy.Target = [leftTarg; rightTarg];
sc3_mTarg_joy.Threshold = joy_radius;
sc3_mTarg_joy.WaitTime = times.joy_waitTime;
sc3_mTarg_joy.HoldTime = times.joy_holdTime;

% Mark behavioral event: probeResp, when MultiTarget choice is acquired
sc3_mTarg_joy_oom = OnOffMarker(sc3_mTarg_joy);
sc3_mTarg_joy_oom.OffMarker = codes.joyOut;
% Mark event when waiting goes from true to false, start of joy
% fixation at selected MultiTarget choice
sc3_mTarg_joy_oom.ChildProperty = 'Waiting';

% AllContinue will be used to continue eye fix, probe image changer, and
% joy multitarget. It will stop once any one of these stops (hopefully, joy
% causing multitarget success).
sc3_joyResp = AllContinue(sc3_mTarg_joy_oom); % this will hopefully end scene when joy moves
sc3_joyResp.add(sc3_wtHold);

% --- CREATE AND RUN SCENE USING ADAPTOR CHAINS
% scene6 will terminate when gaze hold at center is complete, hold time is
% 250 ms, which corresponds to probe duration
scene3 = create_scene(sc3_joyResp, taskObj_fix);
scene3_start = run_scene(scene3, codes.beginRespWindow);


% --- CHECK BEHAVIORAL OUTCOMES
if sc3_mTarg_joy.Success % response made to one of two response windows, not nessarily the correct one
    rt = sc3_mTarg_joy.RT;
    probeRespRT = sc3_mTarg_joy.RT;
    if sc3_mTarg_joy.ChosenTarget == 1 % correct target
        successiveHits = successiveHits + 1;
        trialResult = 'correctChoice';
        resultScene = 'post_probe_resp';
        dashboard(4,sprintf('sc3_mTarg_joy: Correct choice'));
        probeRespChoice = 'correctChoice';
        % --- WRITE EVENT CODE specifying correct response to ML and NI DAQ
        if correctDir == LEFT
            eventmarker(leftCorrResp_eventCode);
        elseif correctDir == RIGHT
            eventmarker(rightCorrResp_eventCode);
        end
        dashboard(3,sprintf('sc3_wtHold: Correct target (x,y) = %d %d', sc3_mTarg_joy.Target(1), sc3_mTarg_joy.Target(2)));
        dashboard(4,sprintf('sc3_wtHold: Chosen target = %d', sc3_mTarg_joy.ChosenTarget));
        dashboard(5,sprintf('sc3_wtHold: Correct choice'));
        dashboard(6,sprintf('sc3_successiveHits = %d', successiveHits));

    elseif sc3_mTarg_joy.ChosenTarget == 2 % incorrect target
        successiveHits = 0;
        successiveErrors = successiveErrors + 1;
        trialResult = 'incorrectChoice';
        resultScene = 'post_probe_resp';
        dashboard(4,sprintf('sc3_mTarg_joy: Incorrect choice'));
        probeRespChoice = 'incorrectChoice';
        % --- WRITE EVENT CODE specifying error response to ML and NI DAQ
        if correctDir == LEFT
            eventmarker(rightErrResp_eventCode); % WRONG DIRECTION
        elseif correctDir == RIGHT
            eventmarker(leftErrResp_eventCode);  % WRONG DIRECTION
        end
        trialerror(6);  %'Incorrect'
        dashboard(3,sprintf('sc3_wtHold: Incorrect target (x,y) = %d %d', sc3_mTarg_joy.Target(1), sc3_mTarg_joy.Target(2)));
        dashboard(4,sprintf('sc3_wtHold: Chosen target = %d', sc3_mTarg_joy.ChosenTarget));
        dashboard(5,sprintf('sc3_wtHold: Incorrect choice'));
    end
elseif sc3_mTarg_joy.Waiting
    idle(0, [], noJoy_eventCode);
    trialerror(1);  %'No response'
    abortTrial = true;
    trialResult = 'noResponse';
    resultScene = 'post_probe_resp';
    dashboard(4, 'sc3_mTarg_joy: Waiting');
elseif sc3_eyeCenter.Success
    % scene terminated with eye in window. Therefore eye did not cause
    % scene to terminate. The joystick caused the scene to terminate.
    % Joystick not success, not waiting, therefore joystick must have
    % acquired target but not been held for HoldTime
    idle(0, [], brokeJoyFix_eventCode);
    trialerror(3);  %'Break fixation'
    abortTrial = true;
    trialResult = 'breakFix_joy';
    resultScene = 'post_probe_resp';
    dashboard(4, 'sc3_mTarg_joy: Fail');
    dashboard(5, 'sc3_eyeCenter: Success');
elseif ~sc3_eyeCenter.Success
    % scene terminated with eye outside of window, eye fixation error
    idle(0, [], brokeGazeFix_eventCode);
    trialerror(3);  %'Break fixation'
    abortTrial = true;
    trialResult = 'breakFix_eye';
    resultScene = 'post_probe_resp';
    dashboard(4, 'sc3_mTarg_joy: In window, holding');
    dashboard(5, 'sc3_eyeCenter: Fail');
end

% bomb trial if error
if abortTrial
    % --- SAVE USER VARS
    bhv_variable(...
        'cuePos', cuePos, ...
        'probePos', probePos, ...
        'cueID', cueID, ...
        'cueStr', cueStr, ...
        'cueFileName', cue_pic, ...
        'probeID', probeID, ...
        'probeStr', probeStr, ...
        'probeFileName', probe_pic, ...
        'trialID', trialTypeID, ...
        'chosenTarget', nan, ...
        'trialResult', trialResult, ...
        'resultScene', resultScene, ...
        'isiTime', isiTime, ...
        'itiTime', itiTime, ...
        'probeRespRT', nan, ...
        'probeReturnRT', nan, ...
        'probeRespChoice', nan, ...
        'probeRespCompleted', probeRespCompleted, ...
        'trialSet', trialSet, ...
        'numConds', TrialRecord.User.numConds, ...
        'condAra', TrialRecord.User.condAra, ...
        'condAraLabel', TrialRecord.User.condAraLabel, ...
        'masterTrialAra', TrialRecord.User.masterTrialAra, ...
        'trialsLeft', TrialRecord.User.trialsLeft);
    return;
end






















% --- ANALYZE SCENE OUTCOME
if sc3_mTarg_joy.Success && ~sc3_key2.Success
    choices.madeValidResp = true;
    choices.responseKey = 1;
    choices.chosenSide = 'left';
    eventmarker(TrialRecord.User.codes.response_key1);
    % --- COMPUTE RT
    rt = sc3_key1.Time - scene3_start;
    % --- LOG CORRECT TRIAL IN TRIALRECORD
    trialerror('validResp');

    % DECREMENT REP COUNTER FOR THIS CONDITION, c is condition number in
    % TrialRecord.User.condRepsRem(c) = TrialRecord.User.condRepsRem(c) - 1;

elseif sc3_key2.Success && ~sc3_key1.Success
    choices.madeValidResp = true;
    choices.responseKey = 2;
    choices.chosenSide = 'right';
    eventmarker(TrialRecord.User.codes.response_key2);
    % --- See comments above for rt
    rt = sc3_key2.Time - scene3_start;
    % --- LOG CORRECT TRIAL IN TRIALRECORD
    trialerror('validResp')

    % DECREMENT REP COUNTER FOR THIS CONDITION, c is condition number in
    % TrialRecord.User.condRepsRem(c) = TrialRecord.User.condRepsRem(c) - 1;

elseif ~sc3_key1.Success && ~sc3_key2.Success
    choices.madeValidResp = false;
    trialerror('noResp');  % no response
    choices.responseKey = 0;

    switch TrialRecord.User.params.stimulusType

        case 'bars'
            bhv_variable( ...
                'TrialRecord', TrialRecord, ...
                'choices', choices, ...
                'condArray', TrialRecord.User.condArray, ...
                'params', TrialRecord.User.params, ...
                'movieFrames', TrialRecord.User.movieFrames, ...
                'movieFrameTimes', TrialRecord.User.movieFrameTimes);

        case 'curves'
            bhv_variable( ...
                'TrialRecord', TrialRecord, ...
                'choices', choices, ...
                'condArray', TrialRecord.User.condArray, ...
                'params', TrialRecord.User.params, ...
                'movieFrames', TrialRecord.User.movieFrames, ...
                'movieFrameTimes', TrialRecord.User.movieFrameTimes, ...
                'movieParams', TrialRecord.User.movieParams);
    end


    % --- 'RETURN' CALL TERMINATES TRIAL EARLY
    return;
end

% -------------------------------------------------------------------------
% SCENE 4: GIVE PROBABILISTIC REWARD AND DISPLAY FEEDBACK

% --- DETERMINE WHETHER TO REWARD TRIAL
% select random number between 0 and 1 to determine probabilistic reward
choices.randNum_rew = rand();

if choices.madeValidResp
    if choices.responseKey == 1
        choices.respStr = 'KEY HIT: LEFT';
        % determine if correct (high value) choice was selected
        if TrialRecord.User.condArray(c).state == 1
            choices.choseCorrect = true;
            if choices.randNum_rew < TrialRecord.User.params.highRewProb  % --- WIN, HIGH PROB ---
                choices.rewardTrial = true;
                TrialRecord.User.blockWins = TrialRecord.User.blockWins + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  WIN, SELECTED HIGH PROB';
            else  % --- LOSS, HIGH PROB ---
                choices.rewardTrial = false;
                TrialRecord.User.blockLosses = TrialRecord.User.blockLosses + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  LOSS, SELECTED HIGH PROB';
            end
        elseif TrialRecord.User.condArray(c).state == 2
            choices.choseCorrect = false;
            if choices.randNum_rew < TrialRecord.User.params.lowRewProb  % --- WIN, LOW PROB ---
                choices.rewardTrial = true;
                TrialRecord.User.blockWins = TrialRecord.User.blockWins + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  WIN, SELECTED LOW PROB';
            else  % --- LOSS, LOW PROB ---
                choices.rewardTrial = false;
                TrialRecord.User.blockLosses = TrialRecord.User.blockLosses + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  LOSS, SELECTED LOW PROB';
            end
        end

    elseif choices.responseKey == 2
        choices.respStr = 'KEY HIT: RIGHT';
        % determine if correct (high value) choice was selected
        if TrialRecord.User.condArray(c).state == 1
            choices.choseCorrect = false;
            if choices.randNum_rew < TrialRecord.User.params.lowRewProb  % --- WIN, LOW PROB ---
                choices.rewardTrial = true;
                TrialRecord.User.blockWins = TrialRecord.User.blockWins + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  WIN, SELECTED LOW PROB';
            else  % --- LOSS, LOW PROB ---
                choices.rewardTrial = false;
                TrialRecord.User.blockLosses = TrialRecord.User.blockLosses + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  LOSS, SELECTED LOW PROB';
            end
        elseif TrialRecord.User.condArray(c).state == 2
            choices.choseCorrect = true;
            if choices.randNum_rew < TrialRecord.User.params.highRewProb  % --- WIN, HIGH PROB ---
                choices.rewardTrial = true;
                TrialRecord.User.blockWins = TrialRecord.User.blockWins + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  WIN, SELECTED HIGH PROB';
            else  % --- LOSS, HIGH PROB ---
                choices.rewardTrial = false;
                TrialRecord.User.blockLosses = TrialRecord.User.blockLosses + 1;
                TrialRecord.User.netWins = TrialRecord.User.blockWins - TrialRecord.User.blockLosses;
                choices.resultStr = '  LOSS, SELECTED HIGH PROB';
            end
        end

    end

else  % NO VALID RESPONSE
    choices.respStr = ' NO RESP';
    choices.resultStr = ' NO RESULT';
end

% --- if blockLosses > blockWins, reset counters to 0 to prevent
% accumulation of a deficit, don't want a hole subj has to dig out of
% before display shows accumulation of additional wins
if TrialRecord.User.netWins < 0
    TrialRecord.User.blockWins = 0;
    TrialRecord.User.blockLosses = 0;
    TrialRecord.User.netWins = 0;
end

% --- SAVE CHOICE INFORMATION to TrialRecord
TrialRecord.User.Choices = choices;

% --- OUTPUT CHOICE REWARD RESULT TO USER SCREEN
respResStr = strcat(choices.respStr, '  ---  ', choices.resultStr);

switch TrialRecord.User.params.stimulusType

    case 'bars'
        dashboard(2, respResStr, [1 1 1], 'FontSize', 8);

    case 'curves'
        dashboard(2, respResStr, [0 0 0], 'FontSize', 8);

end



% --- UPDATE REWARD BOX WITH THIS RESULT
netWinBox_width = TrialRecord.User.netWins * TrialRecord.User.params.rewBox_degPerWin;
netWindBox_center = (netWinBox_width / 2) - (maxWinBox_width / 2);
% rewBox.List = {[1 1 1], [1 1 1], [netWinBox_width netWinBox_height], [netWindBox_center TrialRecord.User.params.rewBox_yPos]; [0 0 0], [0 0 0], [maxWinBox_width netWinBox_height], [0 TrialRecord.User.params.rewBox_yPos - netWinBox_height]};
rewBox.List = {netWinBox_edgeColor, netWinBox_faceColor, [netWinBox_width netWinBox_height], [netWindBox_center TrialRecord.User.params.rewBox_yPos]; [0 0 0], [0 0 0], [maxWinBox_width netWinBox_height], [0 TrialRecord.User.params.rewBox_yPos - netWinBox_height]};


% --- INSTANTIATE IMAGECHANGER OBJ for FEEDBACK MOVIE
sc4_rewImg = ImageChanger(rewBox);

if choices.madeValidResp
    if choices.rewardTrial
        sc4_rewImg.List = ...
            {{choices.choiceImg}, [0 0], times.choiceRing_frames, TrialRecord.User.codes.choiceRing_on; ...
            {choices.rewImg}, [0 0], times.rewRing_frames, TrialRecord.User.codes.rewRing_on};
    else
        sc4_rewImg.List = ...
            {{choices.choiceImg}, [0 0], times.choiceRing_frames, TrialRecord.User.codes.choiceRing_on};
    end
else
    sc4_rewImg.List = ...
        {[choices.errorImg], [0 0], times.choiceRing_frames, TrialRecord.User.codes.noResponse};

end

% --- CREATE AND RUN SCENE USING ADAPTOR CHAINS
scene4 = create_scene(sc4_rewImg, taskObj_fix);
scene4_start = run_scene(scene4);

% --- SAVE DATA TO BHV2 FILE
% NOTE!!: Make sure 'File type' dropdown in GUI is set to BHV2.  Matlab
% format (.mat) works but can't figure out how to control which variables
% get saved to matlab outfile

switch TrialRecord.User.params.stimulusType

    case 'bars'
        bhv_variable( ...
            'TrialRecord', TrialRecord, ...
            'choices', choices, ...
            'condArray', TrialRecord.User.condArray, ...
            'params', TrialRecord.User.params, ...
            'movieFrames', TrialRecord.User.movieFrames, ...
            'movieFrameTimes', TrialRecord.User.movieFrameTimes);

    case 'curves'

        bhv_variable( ...
            'TrialRecord', TrialRecord, ...
            'choices', choices, ...
            'condArray', TrialRecord.User.condArray, ...
            'params', TrialRecord.User.params, ...
            'movieFrames', TrialRecord.User.movieFrames, ...
            'movieFrameTimes', TrialRecord.User.movieFrameTimes, ...
            'movieParams', TrialRecord.User.movieParams);
end



